/// exportWorld2(name, save image, save copy);

var name = argument0;
var savei = argument1;
var savec = argument2;

var error = false;
for (var i = 0; i < ds_list_size(region); i++) {
    if (region.type == 0) {
        if (!(instance_exists(region[| i].chunks[0]) && instance_exists(region[| i].chunks[1])))
        {
            error = true;
        }
    }
    else {
        for (var a = 0; a < MAX_CHUNKS_IN_REGION; a++) {
            if (!instance_exists(region[| i].chunks[a])) {
                error = true;
            }
        }
    }
}

if (error) {
    show_message("Error: Cannot export world!#Must define all chunks for every region!");
    exit;
}

// prepare list of used chunks
var used_chunks = ds_list_create();

with objChunk {
    is_used = false;
}

/*with objRegion {
    event_user(0);
}*/
for (var i = 0; i < ds_list_size(region); i++) {
    with region[| i] {
        event_user(0);
    }
}
/*with objSpecChunk {
    event_user(0);
}*/
for (var i = 0; i < ds_list_size(specchunk); i++) {
    with specchunk[| i] {
        event_user(0);
    }
}

for (var i = 0; i < ds_list_size(chunk); i++) {
    if (chunk[| i].is_used) {
        ds_list_add(used_chunks, chunk[| i]);
        used_chunks[| ds_list_size(used_chunks) - 1].used_index = ds_list_size(used_chunks) - 1;
    }
}

// open file to write to
var file = file_text_open_write("saves\" + name + ".h");

wl(file, "
/// The below code was generated by
/// the TEAM a.r.g. World Editor
/// created by Gavin Atkin 2016-2017
\pifndef __WORLDDATA_H__
\pdefine __WORLDDATA_H__

#include <Arduboy2.h>

extern Arduboy2Base arduboy;
");

wl(file, "\pdefine TOTAL_REGIONS     " + string(ds_list_size(region)));
wl(file, "\pdefine LEVEL_CHUNK_W    32");
wl(file, "\pdefine LEVEL_CHUNK_H    32");

wl(file, "

const int PLAYER_START_X = " + string(player_x) + ";
const int PLAYER_START_Y = " + string(player_y) + ";
int camX = PLAYER_START_X - 64;
int camY = PLAYER_START_Y - 32;
byte waterframe = 0;
");

wl(file, "
// drawTiles
// takes: nothing
// returns: nothing
// Renders the world to the Arduboy screen. To change the view area,
// alter variables camX and camY. Valid values are between 0 and
// 3072 before rendering will not look right.
void drawTiles();

// getChunk
// takes: const byte &chunk_pos_x - X coordinate in chunks [0-32)
//        const byte &chunk_pos_y - Y coordinate in chunks [0-32)
// returns: byte - chunk found at coordinates provided
// Find the chunk at the given position. Used in rendering but could
// also be used to figure out what chunk the player is in for game
// logic.
byte getChunk(const byte &chunk_pos_x, const byte &chunk_pos_y);

// getChunkBit
// takes: const byte &chunk_x - X coordinate in chunks [0-32)
//        const byte &chunk_y - Y coordinate in chunks [0-32)
// returns: bool - whether or not the chunk at provided coordinates is solid (true)
// or empty (false)
// Get whether the chunk at given coordinates is solid or not. This does NOT provide
// collision information for the player directly. To get whether a point is solid for
// player collision use getSolid.
bool getChunkBit(const byte &chunk_x, const byte &chunk_y);

// getTileInChunk
// takes: const byte &chunk - Chunk index to get a tile from
//        byte tile_pos_x - X coordinate of the tile in the chunk [0-6)
//        byte tile_pos_y - Y coordinate of the tile in the chunk [0-6)
// returns: byte - tile index
// Get the tile index from a chunk with the given coordinates. Coordinates must
// be normalized to the chunk already. 
byte getTileInChunk(const byte &chunk, byte tile_pos_x, byte tile_pos_y);

// world_to_chunk
// takes: int world_pos_v - A coordinate value (x or y) in world space [0-3072)
// returns: byte - Input world coordinate converted to chunk coordinate [0-32)
// Convert a world coordinate [0-3072) to a chunk coordinate [0-6).
byte world_to_chunk(int world_pos_v);

// getSolid
// takes: int world_pos_x - X coordinate in the world [0-3072)
//        int world_pos_y - Y coordinate in the world [0-3072)
// returns: bool - Whether or not the position contains a solid tile
// This is used for collision checking for the player or any other entity that should not
// move onto a solid tile.
bool getSolid(int world_pos_x, int world_pos_y);

// getTileID
// takes: int world_pos_x - X coordinate in the world [0-3072)
//        int world_pos_y - Y coordinate in the world [0-3072)
// returns: byte - Tile at the given world position
// Gets the tile index from the world position provided.
byte getTileID(int world_pos_x, int world_pos_y);

// getRegion
// takes: uint8_t chunk_pos_x - X coordinate in chunks [0-32)
//        uint8_t chunk_pos_y - Y coordinate in chunks [0-32)
// returns: byte - Index of the region located at the given chunk location
// Get the index of the region with the provided chunk location. This can be used
// to determine which area the player is in for things like random encounters,
// music changes, etc.
byte getRegion(uint8_t chunk_pos_x, uint8_t chunk_pos_y);

// checkDoors
// takes: int player_x - X coordinate of the player
//        int player_y - Y coordinate of the player
// returns: Point - new x and y coordinates of the player if the player entered a door,
// or old player coordinates if not entering a door.
// Check the player's coordinates for doors. If the player entered a door, returns the new
// player's coordinates, otherwise returns the old player's coordinates.
Point checkDoors(int player_x, int player_y);

");

// Write in Chunk data
writeChunks(file, used_chunks);
file_text_writeln(file);

// Write in Tile data
var spr;
var inum;
if (sprite_exists(custom_tiles)) {
    // Custom Tiles
    spr = custom_tiles;
    inum = sprite_get_number(custom_tiles);
}
else {
    // Default Tiles
    spr = sprTiles;
    inum = sprite_get_number(sprTiles);
}
var tiles;
tiles[9999] = 0;
//spriteToBytes(spr, tiles);
writeTiles(file, spr, tiles, inum, sprite_get_width(spr), sprite_get_height(spr));

// Write in Region Data
writeRegions(file, savei);

// Continue with code
wl(file, "
        
void drawTiles()
{
  for (byte x = 128; x <= 128; x -= 16)
  {
    for (byte y = 64; y <= 64; y -= 16)
    {
      byte tile = getTileID(camX + x, camY + y);
      sprites.drawOverwrite((((camX >> 4) << 4) + x) - camX, (((camY >> 4) << 4) + y) - camY, tileSheet, tile);
    }
  }
  if (!arduboy.everyXFrames(10))
    waterframe = (++waterframe) % 2;
}
");

// getTileInChunk
wl(file, "
byte getTileInChunk(const byte &chunk, byte tile_pos_x, byte tile_pos_y)
{
  return ((pgm_read_byte(chunks + ((chunk & 0x7F) * 18) + (tile_pos_x >> 1) + tile_pos_y * 3) >> ((tile_pos_x % 2) << 2)) & 0x0F);
}

");

writeDoors(file);
        
wl(file, "\pendif");
        
// delete list - close files
file_text_close(file);

if (savec) {
    var savename = get_save_filename_ext("C++ Header File|*.h|C++ Source File|*.cpp", world_internal_name + ".h", program_directory, "Save copy as...");
    if (is_string(savename) && string_length(savename) > 0) {
        file_copy("saves\" + name + ".h", savename);
        //file_copy("saves\" + world_external_name + "_world.png", filename_path(savename) + stringChopN(savename, ".", 0) + ".png")
    }
}

ds_list_destroy(used_chunks);
